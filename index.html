<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SOL/USDC PancakeSwap V3 (Solana) Pool Viewer</title>
  <!-- Chart.js for charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      color-scheme: dark;
      --bg: #020617;
      --bg-elevated: rgba(15, 23, 42, 0.98);
      --border-subtle: rgba(148, 163, 184, 0.22);
      --accent: #49e55e;
      --accent-soft: rgba(16, 229, 94, 0.18);
      --text-main: #e5e7eb;
      --text-muted: #94a3b8;
      --danger: #f97373;
      --radius-lg: 14px;
      --radius-md: 10px;
      --shadow-soft: 0 22px 60px rgba(15, 23, 42, 0.85);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 32px 16px 40px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: var(--text-main);
    }

    .main {
      width: 100%;
      max-width: 960px;
    }

    .page-header {
      margin-bottom: 18px;
    }

    .page-title-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    h1 {
      font-size: 26px;
      letter-spacing: 0.02em;
      margin: 0;
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.28);
      color: var(--text-muted);
      background: rgba(15, 23, 42, 0.75);
    }

    .tagline {
      margin: 0;
      font-size: 13px;
      color: var(--text-muted);
    }

    .small {
      font-size: 12px;
      color: var(--text-muted);
    }

    .card {
      border-radius: var(--radius-lg);
      padding: 18px 20px;
      margin-top: 18px;
      background:
        linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(12, 18, 33, 0.96));
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 8px;
    }

    .card-title {
      font-size: 15px;
      font-weight: 600;
    }

    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15, 118, 110, 0.15);
      border: 1px solid rgba(45, 212, 191, 0.4);
      color: #a5f3fc;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-muted);
    }

    .input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    input {
      flex: 1 1 260px;
      min-width: 0;
      padding: 9px 11px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
      transition: border-color 0.16s ease, box-shadow 0.16s ease, background-color 0.16s ease;
    }

    input::placeholder {
      color: rgba(148, 163, 184, 0.7);
    }

    input:focus {
      border-color: rgba(34, 197, 94, 0.8);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.55);
      background: rgba(15, 23, 42, 1);
    }

    button {
      padding: 9px 16px;
      cursor: pointer;
      border-radius: var(--radius-md);
      border: 1px solid rgba(34, 197, 94, 0.25);
      background: rgba(34, 197, 94, 0.12);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text-main);
      font-weight: 500;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.4), inset 0 1px 0 rgba(34, 197, 94, 0.15);
      transition: background-color 0.16s ease, transform 0.08s ease, box-shadow 0.16s ease, border-color 0.16s ease;
      white-space: nowrap;
    }

    button:hover {
      background: rgba(34, 197, 94, 0.18);
      border-color: rgba(34, 197, 94, 0.35);
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.5), inset 0 1px 0 rgba(34, 197, 94, 0.2);
    }

    button:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.15);
      box-shadow: 0 2px 8px rgba(15, 23, 42, 0.3), inset 0 1px 0 rgba(34, 197, 94, 0.15);
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      background: rgba(34, 197, 94, 0.08);
    }

    .button-icon {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(34, 197, 94, 0.3);
      background: rgba(34, 197, 94, 0.25);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .run-simulation-btn {
      padding: 10px 18px !important;
      font-size: 13px !important;
      font-weight: 600 !important;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(16, 185, 129, 0.2)) !important;
      border: 2px solid rgba(34, 197, 94, 0.5) !important;
      box-shadow: 
        0 6px 20px rgba(34, 197, 94, 0.3),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
      gap: 6px !important;
      position: relative;
      overflow: hidden;
    }

    .run-simulation-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s ease;
    }

    .run-simulation-btn:hover::before {
      left: 100%;
    }

    .run-simulation-btn:hover {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.35), rgba(16, 185, 129, 0.3)) !important;
      border-color: rgba(34, 197, 94, 0.7) !important;
      transform: translateY(-2px) !important;
      box-shadow: 
        0 8px 28px rgba(34, 197, 94, 0.4),
        0 0 0 1px rgba(34, 197, 94, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
    }

    .run-simulation-btn:active {
      transform: translateY(0) !important;
      box-shadow: 
        0 4px 16px rgba(34, 197, 94, 0.25),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
    }

    .play-icon {
      font-size: 14px;
      line-height: 1;
      color: rgba(34, 197, 94, 1);
      text-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      background: rgba(34, 197, 94, 0.2);
      border-radius: 50%;
      border: 1px solid rgba(34, 197, 94, 0.4);
    }

    .loading-text {
      min-height: 16px;
    }

    .error {
      color: var(--danger);
      margin-top: 8px;
      font-size: 12px;
    }

    .results-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .results-title {
      font-size: 16px;
      font-weight: 600;
    }

    .muted-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 10px 18px;
      margin-bottom: 10px;
    }

    .stat {
      padding: 8px 10px;
      border-radius: 10px;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), transparent 55%);
      border: 1px solid rgba(148, 163, 184, 0.26);
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .clickable-stat .stat-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .stat-value {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-main);
      word-break: break-all;
    }

    .clickable-stat {
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
      user-select: none;
    }

    .clickable-stat:hover {
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.12), transparent 55%);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .clickable-stat:active {
      transform: translateY(0);
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.08), transparent 55%);
    }

    .swap-icon {
      font-size: 14px;
      color: var(--accent);
      opacity: 0.7;
      transition: transform 0.3s ease, opacity 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .clickable-stat:hover .swap-icon {
      opacity: 1;
      transform: rotate(180deg);
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
    }

    pre {
      font-size: 11px;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 12px;
      padding: 10px 12px;
      max-height: 320px;
      overflow: auto;
      border: 1px solid rgba(30, 64, 175, 0.5);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.8);
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 11px;
      color: #a5b4fc;
    }

    /* chart card */
    .chart-container {
      margin-top: 16px;
    }

    .range-control {
      margin: 12px 0 6px;
      padding: 12px 14px 14px;
      border-radius: 14px;
      border: 1px solid rgba(34, 197, 94, 0.25);
      background:
        linear-gradient(135deg, rgba(15, 118, 110, 0.15), rgba(34, 197, 94, 0.05)),
        rgba(15, 23, 42, 0.85);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.45), 0 10px 25px rgba(15, 23, 42, 0.5);
    }

    .range-meta {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.75);
    }

    #daysRange {
      width: 100%;
      appearance: none;
      -webkit-appearance: none;
      margin-top: 12px;
      height: 6px;
      background: transparent;
      cursor: pointer;
    }

    #daysRange::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.8));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #daysRange::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.8));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #daysRange::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(15, 23, 42, 0.95);
      background:
        radial-gradient(circle at 30% 30%, rgba(34, 197, 94, 0.4), #216e3e, #15803d);
      box-shadow: 0 4px 12px rgba(21, 128, 61, 0.35), inset 0 1px 0 rgba(34, 197, 94, 0.2);
      margin-top: -7px;
      transition: box-shadow 0.2s ease;
    }

    #daysRange::-webkit-slider-thumb:hover {
      box-shadow: 0 5px 16px rgba(21, 128, 61, 0.45), inset 0 1px 0 rgba(34, 197, 94, 0.3);
    }

    #daysRange::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(15, 23, 42, 0.95);
      background:
        radial-gradient(circle at 30% 30%, rgba(34, 197, 94, 0.4), #136e34, #15803d);
      box-shadow: 0 4px 12px rgba(21, 128, 61, 0.35), inset 0 1px 0 rgba(34, 197, 94, 0.2);
      transition: box-shadow 0.2s ease;
    }

    #daysRange::-moz-range-thumb:hover {
      box-shadow: 0 5px 16px rgba(21, 128, 61, 0.45), inset 0 1px 0 rgba(34, 197, 94, 0.3);
    }

    #daysRange:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.4);
    }

    .chart-wrapper {
      position: relative;
      width: 100%;
      height: 260px;
      margin-top: 10px;
      border-radius: 12px;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 10px 12px 12px;
    }

    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .chart-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: opacity 0.2s ease;
    }

    .chart-legend-item:hover {
      opacity: 0.8;
    }

    .chart-legend-item.legend-hidden {
      opacity: 0.4;
    }

    .chart-legend-item.legend-hidden .legend-dot {
      opacity: 0.4;
    }

    .chart-legend-item.legend-hidden span:not(.legend-dot) {
      text-decoration: line-through;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .collapsible-section {
      margin-bottom: 6px;
    }

    .collapsible-header {
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 4px 0;
      user-select: none;
      transition: opacity 0.2s ease;
    }

    .collapsible-header:hover {
      opacity: 0.8;
    }

    .collapsible-arrow {
      display: inline-block;
      font-size: 10px;
      color: var(--text-muted);
      transition: transform 0.2s ease;
      width: 12px;
      text-align: center;
    }

    .collapsible-content {
      margin-top: 8px;
      animation: fadeIn 0.2s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* Popular pools selection bar */
    .popular-pools-container {
      margin-bottom: 12px;
      overflow: hidden;
      position: relative;
      padding: 8px 0;
      mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
      -webkit-mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
    }

    .popular-pools-scroll {
      display: flex;
      gap: 8px;
      animation: scrollHorizontal 40s linear infinite;
      width: fit-content;
    }

    .popular-pools-scroll:hover {
      animation-play-state: paused;
    }

    @keyframes scrollHorizontal {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-50%);
      }
    }

    .popular-pool-item {
      padding: 6px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text-main);
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
      user-select: none;
      flex-shrink: 0;
    }

    .popular-pool-item:hover {
      background: rgba(34, 197, 94, 0.15);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .popular-pool-item:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.2);
    }

    .popular-pools-scroll::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 40px;
      height: 100%;
      background: linear-gradient(to right, transparent, rgba(15, 23, 42, 0.95));
      pointer-events: none;
      z-index: 1;
    }

    @media (max-width: 640px) {
      body {
        padding-top: 22px;
      }

      .card {
        padding: 16px 14px;
      }

      h1 {
        font-size: 22px;
      }

      button {
        width: 100%;
        justify-content: center;
      }

      .chart-wrapper {
        height: 240px;
      }
    }
  </style>
</head>
<body>
  <main class="main">
    <header class="page-header">
      <div class="page-title-row">
        <h1>Liquidity Pool Tracker</h1>
        <span class="pill">Solana</span>
      </div>
      <p class="tagline">
        <code>Live pool metrics fetched from the GeckoTerminal DEX API</code>
      </p>
    </header>

    <div class="card">
      <div class="card-header">
        <div class="card-title">Pool ID</div>
        <span class="badge">GeckoTerminal Pool Address</span>
      </div>

      <div class="popular-pools-container">
        <div class="popular-pools-scroll" id="popularPoolsScroll">
          <!-- Popular pools will be duplicated for seamless loop -->
        </div>
      </div>

      <label for="poolId">Paste any Solana pool address to inspect its stats.</label>
      <div class="input-row">
        <input
          id="poolId"
          type="text"
          value="DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ"
          placeholder="DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ"
        />
        <button id="loadBtn">
          <span class="button-icon"></span>
           Load Pool
        </button>
      </div>
      <div style="margin-top: 10px;">
        <button 
          id="toggleCustomKeyBtn" 
          type="button"
          style="padding: 0; margin: 0; border: none; background: transparent; box-shadow: none; outline: none; cursor: pointer;"
        >
          <span id="toggleCustomKeyText" style="color: rgba(148, 163, 184, 0.4); font-size: 10px; font-family: monospace;">api_key_config</span>
          <span id="toggleCustomKeyArrow" style="margin-left: 6px; color: rgba(148, 163, 184, 0.4); font-size: 10px;">‚ñº</span>
        </button>
        <div id="customKeySection" style="display: none; margin-top: 8px;">
          <div class="input-row">
            <input
              id="birdeyeApiKey"
              type="password"
              placeholder="Enter your Birdeye API Key"
              autocomplete="off"
            />
            <button id="toggleKeyVisibilityBtn" type="button" title="Show/Hide API Key" style="padding: 9px 12px;">
              üëÅÔ∏è
            </button>
            <button id="checkBirdeyeKeyBtn">
              <span class="button-icon"></span>
              Check Key
            </button>
          </div>
          <div class="small" id="birdeyeStatus" style="margin-top: 4px; opacity: 0.9;"></div>

        </div>
        <div class="small" style="margin-top: 6px; opacity: 0.8; color: var(--text-muted);">
          Default uses built-in API Key. To use your own Key, please click the button above.
        </div>
      </div>
      <div class="small loading-text" id="loading"></div>
      <div id="error" class="error"></div>
    </div>

    <div id="results" class="card" style="display:none;">
      <div class="results-card-header">
        <div>
          <div class="results-title">Parsed Pool Data</div>
          <div class="muted-label">Key metrics</div>
        </div>
        <div class="muted-label">Live from GeckoTerminal</div>
      </div>
      <div id="poolInfo"></div>

      <!-- chart area -->
      <div class="chart-container">
        <div class="muted-label">
          Last <span id="daysLabel">30</span> Days Liquidity & Volume
        </div>
        <div class="small">
          TVL line uses current liquidity as an approximate level, daily volume from OHLCV candles.
        </div>

        <div class="range-control">
          <div class="range-meta">
            <span>Lookback window</span>
            <span></span>
          </div>
          <input
            id="daysRange"
            type="range"
            min="2"
            max="180"
            step="1"
            value="30"
          />
        </div>

        <div class="chart-wrapper">
          <canvas id="tvlVolumeChart"></canvas>
        </div>
        <div class="chart-legend">
          <div class="chart-legend-item" id="tvlLegend">
            <span class="legend-dot" style="background: #1d5331;"></span>
            <span>TVL (USD)</span>
          </div>
          <div class="chart-legend-item" id="volumeLegend">
            <span class="legend-dot" style="background: rgba(148, 163, 184, 0.9);"></span>
            <span>Daily Volume (USD)</span>
          </div>
          <div class="chart-legend-item" id="token0HighLegend">
            <span class="legend-dot" style="background: rgba(250, 204, 21, 0.9);"></span>
            <span id="token0HighLabel">High Price</span>
          </div>
          <div class="chart-legend-item" id="token0LowLegend">
            <span class="legend-dot" style="background: rgba(248, 113, 113, 0.9);"></span>
            <span id="token0LowLabel">Low Price</span>
          </div>
          <div class="chart-legend-item" id="token1HighLegend">
            <span class="legend-dot" style="background: rgba(59, 130, 246, 0.9);"></span>
            <span id="token1HighLabel">High Price</span>
          </div>
          <div class="chart-legend-item" id="token1LowLegend">
            <span class="legend-dot" style="background: rgba(139, 92, 246, 0.9);"></span>
            <span id="token1LowLabel">Low Price</span>
          </div>
        </div>
      </div>

      <div class="collapsible-section" style="margin-top: 14px;">
        <div class="collapsible-header" onclick="toggleCollapsible('rawJsonSection')">
          <span class="collapsible-arrow" id="rawJsonArrow">‚ñ∂</span>
          <span class="muted-label" style="margin-left: 6px;">Raw GeckoTerminal Response</span>
          <span class="small" style="margin-left: 8px; opacity: 0.7;">Full JSON payload from GeckoTerminal pool snapshot API.</span>
        </div>
        <div class="collapsible-content" id="rawJsonSection" style="display: none;">
          <pre id="rawJson"></pre>
        </div>
      </div>

      <div class="collapsible-section" style="margin-top: 10px;">
        <div class="collapsible-header" onclick="toggleCollapsible('birdeyeRawJsonSection')">
          <span class="collapsible-arrow" id="birdeyeRawJsonArrow">‚ñ∂</span>
          <span class="muted-label" style="margin-left: 6px;">Raw Birdeye OHLCV Response</span>
          <span class="small" style="margin-left: 8px; opacity: 0.7;">Full JSON payload from Birdeye OHLCV API (if available).</span>
        </div>
        <div class="collapsible-content" id="birdeyeRawJsonSection" style="display: none;">
          <pre id="birdeyeRawJson"></pre>
        </div>
      </div>
    </div>

    <!-- Impermanent Loss Simulator -->
    <div class="card" id="ilSimulatorCard" style="margin-top: 20px;">
      <div class="card-header">
        <div>
          <div class="card-title">Impermanent Loss Simulator</div>
          <div class="muted-label">PancakeSwap V3 ¬∑ SOL / USDC ¬∑ Monte Carlo</div>
        </div>
        <span class="badge">IL ¬∑ Distribution ¬∑ CI</span>
      </div>

      <p class="small" style="margin-bottom: 10px;">
        Enter the concentrated liquidity range, current price, daily volatility, and time period. Use geometric Brownian motion to perform Monte Carlo simulation on future prices, estimating expected IL, distribution, and confidence intervals.
      </p>

      <!-- Input Area -->
      <div class="stat-grid" style="margin-bottom: 8px;">
        <div class="stat">
          <div class="stat-label">Price lower bound</div>
          <input
            id="ilLower"
            type="number"
            step="0.0001"
            placeholder="e.g. 100"
            value="100"
          />
        </div>
        <div class="stat">
          <div class="stat-label">Price upper bound</div>
          <input
            id="ilUpper"
            type="number"
            step="0.0001"
            placeholder="e.g. 200"
            value="200"
          />
        </div>
        <div class="stat">
          <div class="stat-label">Current price (P‚ÇÄ)</div>
          <input
            id="ilP0"
            type="number"
            step="0.0001"
            placeholder="e.g. 130"
            value="130"
          />
        </div>
      </div>

      <div class="stat-grid" style="margin-bottom: 4px;">
        <div class="stat">
          <div class="stat-label">Daily volatility  (percent)</div>
          <input
            id="ilSigmaDaily"
            type="number"
            step="0.01"
            placeholder="e.g. 7.26 means 7.26%"
            value="7.26"
          />
        </div>
        <div class="stat">
          <div class="stat-label">simulation days</div>
          <input
            id="ilDays"
            type="number"
            step="1"
            min="1"
            placeholder="Forecast days, e.g. 30"
            value="30"
          />
        </div>
        <div class="stat">
          <div class="stat-label">Number of paths</div>
          <input
            id="ilPaths"
            type="number"
            step="100"
            min="100"
            placeholder="Number of simulations, default 1000"
            value="1000"
          />
        </div>
      </div>

      <div style="margin-top: 6px; margin-bottom: 4px; display: flex; flex-direction: column; align-items: center; gap: 8px;">
        <button id="runIlBtn" class="run-simulation-btn">
          <span class="play-icon">‚ñ∂</span>
          Run Simulation
        </button>
        <span class="small" id="ilStatus"></span>
      </div>
      <div class="error" id="ilError"></div>

      <!-- Output Overview -->
      <div style="margin-top: 12px;">
        <div class="muted-label" style="margin-bottom: 4px;">Simulation results</div>
        <div class="stat-grid">
          <div class="stat">
            <div class="stat-label">Expected IL</div>
            <div class="stat-value" id="ilExpected">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label">Equivalent IL APR</div>
            <div class="stat-value" id="ilApr">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label">Fee Break-even APR</div>
            <div class="stat-value" id="ilFeeBreakEven">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label">5% ‚Äì 95% IL interval</div>
            <div class="stat-value" id="ilCI">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label">Std. deviation of IL</div>
            <div class="stat-value" id="ilStd">‚Äì</div>
          </div>
        </div>
      </div>

      <!-- Distribution Chart -->
      <div class="chart-container" style="margin-top: 12px;">
        <div class="muted-label">IL distribution (percent)</div>
        <div class="small">
          Based on IL samples obtained from Monte Carlo simulation, bin the results and plot as a frequency histogram.
        </div>
        <div class="chart-wrapper" style="margin-top: 10px;">
          <canvas id="ilDistributionChart"></canvas>
        </div>
        <div class="chart-legend" style="margin-top: 6px;">
          <div class="chart-legend-item">
            <span class="legend-dot" style="background: rgba(148,163,184,0.9);"></span>
            <span>Frequency of simulated IL</span>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    const API_BASE = "https://api.geckoterminal.com/api/v2";
    const BIRDEYE_BASE = "https://public-api.birdeye.so";

    function toggleCollapsible(sectionId) {
      const section = document.getElementById(sectionId);
      const arrow = document.getElementById(sectionId.replace('Section', 'Arrow'));
      if (section && arrow) {
        const isExpanded = section.style.display !== 'none';
        section.style.display = isExpanded ? 'none' : 'block';
        arrow.textContent = isExpanded ? '‚ñ∂' : '‚ñº';
      }
    }

    // Format number to 12 significant digits
    function toSignificantDigits(num, digits = 12) {
      // Ensure input is a number type
      if (typeof num !== 'number') {
        num = Number(num);
      }
      
      if (!Number.isFinite(num)) {
        return String(num);
      }
      
      if (num === 0) {
        return "0";
      }
      
      // Use toPrecision to ensure specified number of significant digits
      const formatted = num.toPrecision(digits);
      
      // If result contains scientific notation (e or E), return directly
      if (formatted.includes('e') || formatted.includes('E')) {
        return formatted;
      }
      
      // Remove trailing unnecessary zeros
      // Example: 139.387752996000 -> 139.387752996
      // Note: parseFloat may lose some precision, so we need to handle carefully
      const parsed = parseFloat(formatted);
      const parsedStr = parsed.toString();
      
      // If parsed string length is reasonable, use it (more concise)
      // Otherwise use the original toPrecision result
      if (parsedStr.length <= formatted.length + 2) {
        return parsedStr;
      }
      
      return formatted;
    }

    // ========== Default API Key Configuration ==========
    // To set a default API Key, follow these steps:
    // 1. Run in browser console: obfuscateKey('your actual API Key')
    // 2. Replace the DEFAULT_BIRDEYE_API_KEY_OBFUSCATED value below with the returned obfuscated string
    // 3. Save the file
    // 
    // Example:
    // const DEFAULT_BIRDEYE_API_KEY_OBFUSCATED = 'QXJhY2h5X0FQSV9LZXlfMTIzNDU2Nzg5MA==';
    const DEFAULT_BIRDEYE_API_KEY_OBFUSCATED = 'YOUR_OBFUSCATED_KEY_HERE'; // Please replace with obfuscated API Key

    // Simple obfuscation function (only to prevent casual users from seeing it, cannot prevent professional users)
    // Warning: Pure frontend encryption cannot truly protect API Key, this is only obfuscation
    function obfuscateKey(key) {
      if (!key) return null;
      // Use simple character offset + Base64 encoding
      const offset = 13; // ROT13-like
      let obfuscated = '';
      for (let i = 0; i < key.length; i++) {
        const charCode = key.charCodeAt(i);
        obfuscated += String.fromCharCode(charCode + offset);
      }
      return btoa(obfuscated); // Base64 encoding
    }

    function deobfuscateKey(obfuscated) {
      if (!obfuscated) return null;
      try {
        const decoded = atob(obfuscated); // Base64 decoding
        const offset = 13;
        let key = '';
        for (let i = 0; i < decoded.length; i++) {
          const charCode = decoded.charCodeAt(i);
          key += String.fromCharCode(charCode - offset);
        }
        return key;
      } catch (e) {
        console.error('Failed to deobfuscate key:', e);
        return null;
      }
    }

    // Get default API Key (if set)
    function getDefaultBirdeyeApiKey() {
      // Check if default Key is set (not a placeholder)
      if (!DEFAULT_BIRDEYE_API_KEY_OBFUSCATED || DEFAULT_BIRDEYE_API_KEY_OBFUSCATED === 'YOUR_OBFUSCATED_KEY_HERE') {
        return null;
      }
      
      try {
        const deobfuscated = deobfuscateKey(DEFAULT_BIRDEYE_API_KEY_OBFUSCATED);
        if (deobfuscated && deobfuscated.trim()) {
          return deobfuscated.trim();
        }
      } catch (e) {
        console.error("Failed to deobfuscate default API key:", e);
      }
      
      return null;
    }

    // Read obfuscated key from localStorage (if exists)
    function getStoredBirdeyeApiKey() {
      try {
        const stored = localStorage.getItem('birdeye_api_key_obf');
        if (stored) {
          return deobfuscateKey(stored);
        }
      } catch (e) {
        console.error('Failed to read stored key:', e);
      }
      return null;
    }

    // Save obfuscated key to localStorage
    function storeBirdeyeApiKey(key) {
      try {
        if (key && key.trim()) {
          const obfuscated = obfuscateKey(key.trim());
          localStorage.setItem('birdeye_api_key_obf', obfuscated);
        } else {
          localStorage.removeItem('birdeye_api_key_obf');
        }
      } catch (e) {
        console.error('Failed to store key:', e);
      }
    }

    function getBirdeyeApiKey() {
      // Priority 1: Get from input field (user newly entered)
      const el = document.getElementById("birdeyeApiKey");
      if (el && el.value && el.value.trim()) {
        const inputKey = el.value.trim();
        // Automatically save to localStorage
        storeBirdeyeApiKey(inputKey);
        return inputKey;
      }
      
      // Priority 2: Read from localStorage (user previously saved)
      const storedKey = getStoredBirdeyeApiKey();
      if (storedKey) {
        return storedKey;
      }
      
      // ‰ºòÂÖàÁ∫ß 3: ‰ΩøÁî®ÈªòËÆ§ÁöÑ API KeyÔºàÊ∑∑Ê∑ÜÂêéÁöÑÔºâ- ÂΩìËæìÂÖ•Ê°Ü‰∏∫Á©∫Êó∂Ëá™Âä®‰ΩøÁî®
      const defaultKey = getDefaultBirdeyeApiKey();
      if (defaultKey) {
        console.log("‰ΩøÁî®ÈªòËÆ§ÁöÑ Birdeye API KeyÔºàËæìÂÖ•Ê°Ü‰∏∫Á©∫Ôºâ");
        return defaultKey;
      }
      
      // If all methods fail, return null
      console.warn("Birdeye API Key not found: input field is empty, localStorage is empty, and no default Key is set");
      return null;
    }

    let currentDays = 30; // Currently selected days (controlled by slider), default 30 days
    let tvlVolumeChartInstance = null;
    let storedOhlcvData = []; // Store complete 180 days of data [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
    let currentBaseSymbol = "N/A";
    let currentQuoteSymbol = "N/A";

    async function fetchOhlcv(poolId, days, token = "base") {
      const limit = days ?? currentDays;
      const url = `${API_BASE}/networks/solana/pools/${poolId}/ohlcv/day?aggregate=1&limit=${limit}&currency=usd&token=${token}`;
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`OHLCV HTTP error ${resp.status} (${resp.statusText})`);
      }
      const json = await resp.json();
      const list = json?.data?.attributes?.ohlcv_list || [];
      return list;
    }

    async function fetchBirdeyeOhlcv(poolId, days) {
      const apiKey = getBirdeyeApiKey();
      if (!apiKey) {
        throw new Error("Birdeye API Key is required. Please enter your API key in the input field above.");
      }

      const nowSec = Math.floor(Date.now() / 1000);
      const lookbackDays = days ?? currentDays;
      // Add 1 day buffer
      const fromSec = nowSec - (lookbackDays + 1) * 24 * 60 * 60;

      const url = `${BIRDEYE_BASE}/defi/ohlcv/pair?address=${poolId}&type=1D&time_from=${fromSec}&time_to=${nowSec}`;
      const headers = {
        "accept": "application/json",
        "x-chain": "solana",
        "X-API-KEY": apiKey
      };

      const resp = await fetch(url, { headers });
      if (!resp.ok) {
        throw new Error(`Birdeye OHLCV HTTP error ${resp.status} (${resp.statusText})`);
      }
      const json = await resp.json();

      // Display Birdeye raw response (if corresponding container exists)
      const birdeyeRawEl = document.getElementById("birdeyeRawJson");
      if (birdeyeRawEl) {
        birdeyeRawEl.textContent = JSON.stringify(json, null, 2);
      }

      const data = json && json.data ? json.data : null;

      const rawItems =
        (data && (data.items || data.ohlcv_list || data.ohlcv || data.candles)) ||
        (Array.isArray(data) ? data : []) ||
        [];

      const normalized = rawItems
        .map((item) => {
          if (Array.isArray(item)) {
            const ts = Number(item[0] ?? 0);
            const open = Number(item[1] ?? 0);
            const high = Number(item[2] ?? open);
            const low = Number(item[3] ?? open);
            const close = Number(item[4] ?? open);
            const volume = Number(item[5] ?? 0);
            // Try to read TVL from column 7/8 (if available)
            const tvlCandidate = Number(item[6] ?? item[7] ?? 0);
            const tvl = Number.isFinite(tvlCandidate) && tvlCandidate > 0 ? tvlCandidate : null;
            // Try to read trade count from subsequent columns (if available)
            const tradesCandidate = Number(item[8] ?? item[9] ?? 0);
            const trades =
              Number.isFinite(tradesCandidate) && tradesCandidate >= 0 ? tradesCandidate : 0;
            return [ts, open, high, low, close, volume, tvl, trades];
          } else if (item && typeof item === "object") {
            const ts = Number(item.unixTime ?? item.time ?? item.t ?? 0);
            const open = Number(item.open ?? item.o ?? 0);
            const high = Number(item.high ?? item.h ?? open);
            const low = Number(item.low ?? item.l ?? open);
            const close = Number(item.close ?? item.c ?? open);
            const volume = Number(item.volume ?? item.v ?? 0);
            // Try common TVL field names
            const tvlCandidate = Number(
              item.tvl ?? item.tvlUsd ?? item.tvl_usd ??
              item.liquidity ?? item.liquidityUsd ?? item.liquidity_usd ?? 0
            );
            const tvl = Number.isFinite(tvlCandidate) && tvlCandidate > 0 ? tvlCandidate : null;
            // Try common trade count field names
            const tradesCandidate = Number(
              item.n ?? item.txCount ?? item.trades ?? item.tradeCount ?? 0
            );
            const trades =
              Number.isFinite(tradesCandidate) && tradesCandidate >= 0 ? tradesCandidate : 0;
            return [ts, open, high, low, close, volume, tvl, trades];
          }
          return null;
        })
        .filter((row) => Array.isArray(row) && row[0]);

      // Pad one entry per day according to slider days (use placeholder for days without data)
      const daysCount = lookbackDays;
      const endDay = Math.floor(nowSec / 86400) * 86400; // Today 00:00
      const startDay = endDay - (daysCount - 1) * 86400;

      // First normalize keys by "day"
      const byDay = new Map();
      normalized.forEach((row) => {
        const ts = row[0];
        const dayTs = Math.floor(ts / 86400) * 86400;
        // Latest entry overwrites old (if multiple entries on same day)
        byDay.set(dayTs, row);
      });

      const padded = [];
      for (let t = startDay; t <= endDay; t += 86400) {
        if (byDay.has(t)) {
          padded.push(byDay.get(t));
        } else {
          // Days without data, use placeholder: price null, volume 0, TVL null, trade count 0
          padded.push([t, null, null, null, null, 0, null, 0]);
        }
      }

      return padded;
    }

    async function checkBirdeyeKey() {
      const statusEl = document.getElementById("birdeyeStatus");
      if (!statusEl) return;

      const key = getBirdeyeApiKey();
      if (!key) {
        statusEl.textContent = "Birdeye API Key is empty.";
        statusEl.style.color = "var(--danger)";
        return;
      }

      // Check if using default key (by checking if input field is empty)
      const keyInput = document.getElementById("birdeyeApiKey");
      const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
      
      statusEl.textContent = isUsingDefaultKey 
        ? "Checking default Birdeye API Key..." 
        : "Checking Birdeye API Key...";
      statusEl.style.color = "var(--text-muted)";

      // Use current poolId (or default) to test if data can be fetched normally
      const poolInput = document.getElementById("poolId");
      const fallbackPoolId = "DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ";
      const testPoolId =
        (poolInput && (poolInput.value || "").trim()) || fallbackPoolId;

      try {
        const list = await fetchBirdeyeOhlcv(testPoolId, 1);
        if (Array.isArray(list) && list.length > 0) {
          const keyInput = document.getElementById("birdeyeApiKey");
          const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
          statusEl.textContent = isUsingDefaultKey 
            ? "Default Birdeye API Key is available." 
            : "Birdeye API Key is available.";
          statusEl.style.color = "var(--accent)";
        } else {
          statusEl.textContent =
            "Birdeye API Key request succeeded but returned no data, may be a permission or test pool issue.";
          statusEl.style.color = "var(--text-muted)";
        }
      } catch (e) {
        console.error("Birdeye key check failed", e);
        const msg = e && e.message ? e.message : String(e);
        const keyInput = document.getElementById("birdeyeApiKey");
        const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
        statusEl.textContent = isUsingDefaultKey
          ? `Default Birdeye API Key is unavailable: ${msg}. Please use your own API Key.`
          : `Birdeye API Key is unavailable: ${msg}`;
        statusEl.style.color = "var(--danger)";
      }
    }

    function buildTvlVolumeChart(
      ctx,
      labels,
      tvlData,
      volData,
      hasTvl,
      _openData = [],      // No longer using open/close, only keeping high/low
      highData0 = [],
      lowData0 = [],
      _closeData = [],
      hasPrice0 = false,
      highData1 = [],
      lowData1 = [],
      hasPrice1 = false,
      hiddenStates = {}    // Save dataset hidden state
    ) {
      if (tvlVolumeChartInstance) {
        tvlVolumeChartInstance.destroy();
      }

      const datasets = [];

      if (hasTvl) {
        datasets.push({
          type: "line",
          label: "TVL (USD)",
          data: tvlData,
          borderColor: "#22c55e",
          backgroundColor: "rgba(34, 197, 94, 0.15)",
          borderWidth: 2,
          tension: 0.3,
          yAxisID: "y",
          pointRadius: 2.5,
          pointHoverRadius: 4
        });
      }

      if (hasPrice0) {
        datasets.push(
          {
            type: "line",
            label: `${currentBaseSymbol} High`,
            data: highData0,
            borderColor: "rgba(250, 204, 21, 0.9)",
            backgroundColor: "rgba(250, 204, 21, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          },
          {
            type: "line",
            label: `${currentBaseSymbol} Low`,
            data: lowData0,
            borderColor: "rgba(248, 113, 113, 0.9)",
            backgroundColor: "rgba(248, 113, 113, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          }
        );
      }

      if (hasPrice1) {
        datasets.push(
          {
            type: "line",
            label: `${currentQuoteSymbol} High`,
            data: highData1,
            borderColor: "rgba(59, 130, 246, 0.9)",  // blue
            backgroundColor: "rgba(59, 130, 246, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          },
          {
            type: "line",
            label: `${currentQuoteSymbol} Low`,
            data: lowData1,
            borderColor: "rgba(139, 92, 246, 0.9)",  // purple
            backgroundColor: "rgba(139, 92, 246, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          }
        );
      }

      datasets.push({
        type: "bar",
        label: "Volume (USD)",
        data: volData,
        backgroundColor: "rgba(148, 163, 184, 0.65)",
        borderColor: "rgba(148, 163, 184, 0.9)",
        borderWidth: 1,
        yAxisID: "y1",
        maxBarThickness: 18
      });

      tvlVolumeChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              mode: "index",
              intersect: false,
              backgroundColor: "rgba(15, 23, 42, 0.95)",
              borderColor: "rgba(148, 163, 184, 0.5)",
              borderWidth: 1,
              padding: 10,
              titleFont: {
                size: 12
              },
              bodyFont: {
                size: 11
              },
              callbacks: {
                label: function (ctx) {
                  const label = ctx.dataset.label || "";
                  const value = ctx.parsed.y;
                  if (value == null) return "";
                  const formatted =
                    Math.abs(value) >= 1e9
                      ? (value / 1e9).toFixed(2) + "B"
                      : Math.abs(value) >= 1e6
                      ? (value / 1e6).toFixed(2) + "M"
                      : Math.abs(value) >= 1e3
                      ? (value / 1e3).toFixed(2) + "K"
                      : value.toFixed(2);
                  return `${label}: ${formatted} USD`;
                }
              }
            }
          },
          interaction: {
            mode: "index",
            intersect: false
          },
          scales: {
            x: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: {
                  size: 11
                }
              },
              grid: {
                display: false
              }
            },
            y: {
              position: "left",
              ticks: {
                color: "rgba(34, 197, 94, 0.9)",
                font: {
                  size: 10
                },
                callback: function (value) {
                  if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1) + "B";
                  if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1) + "M";
                  if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(0) + "K";
                  return value;
                }
              },
              grid: {
                color: "rgba(30, 64, 175, 0.25)"
              }
            },
            y1: {
              position: "right",
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: {
                  size: 10
                },
                callback: function (value) {
                  if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1) + "B";
                  if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1) + "M";
                  if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(0) + "K";
                  return value;
                }
              },
              grid: {
                display: false
              }
            }
          }
        }
      });

      // Restore dataset hidden state
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset) => {
          if (dataset.label && hiddenStates.hasOwnProperty(dataset.label)) {
            dataset.hidden = hiddenStates[dataset.label];
          }
        });
        // Â¶ÇÊûúÊúâ‰ªª‰ΩïÊï∞ÊçÆÈõÜË¢´ÈöêËóèÔºåÊõ¥Êñ∞ÂõæË°®
        const hasHidden = tvlVolumeChartInstance.data.datasets.some(d => d.hidden);
        if (hasHidden) {
          tvlVolumeChartInstance.update('none'); // 'none' Ê®°ÂºèÈÅøÂÖçÂä®Áîª
        }
      }

      // Control whether TVL is displayed in legend
      const tvlLegendEl = document.getElementById("tvlLegend");
      if (tvlLegendEl) {
        tvlLegendEl.style.display = hasTvl ? "inline-flex" : "none";
        if (hasTvl) {
          // Find TVL dataset index
          const tvlDatasetIndex = datasets.findIndex(d => d.label === "TVL (USD)");
          if (tvlDatasetIndex !== -1) {
            tvlLegendEl.setAttribute("data-dataset-index", tvlDatasetIndex);
            tvlLegendEl.style.cursor = "pointer";
            tvlLegendEl.classList.remove("legend-hidden");
          }
        }
      }

      // Update token0 price legend
      const token0HighLegendEl = document.getElementById("token0HighLegend");
      const token0LowLegendEl = document.getElementById("token0LowLegend");
      const token0HighLabelEl = document.getElementById("token0HighLabel");
      const token0LowLabelEl = document.getElementById("token0LowLabel");
      if (token0HighLegendEl) {
        token0HighLegendEl.style.display = hasPrice0 ? "inline-flex" : "none";
        if (hasPrice0) {
          const highDatasetIndex = datasets.findIndex(d => d.label === `${currentBaseSymbol} High`);
          if (highDatasetIndex !== -1) {
            token0HighLegendEl.setAttribute("data-dataset-index", highDatasetIndex);
            token0HighLegendEl.style.cursor = "pointer";
            token0HighLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token0LowLegendEl) {
        token0LowLegendEl.style.display = hasPrice0 ? "inline-flex" : "none";
        if (hasPrice0) {
          const lowDatasetIndex = datasets.findIndex(d => d.label === `${currentBaseSymbol} Low`);
          if (lowDatasetIndex !== -1) {
            token0LowLegendEl.setAttribute("data-dataset-index", lowDatasetIndex);
            token0LowLegendEl.style.cursor = "pointer";
            token0LowLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token0HighLabelEl && hasPrice0) {
        token0HighLabelEl.textContent = `${currentBaseSymbol} High`;
      }
      if (token0LowLabelEl && hasPrice0) {
        token0LowLabelEl.textContent = `${currentBaseSymbol} Low`;
      }

      // Update token1 price legend
      const token1HighLegendEl = document.getElementById("token1HighLegend");
      const token1LowLegendEl = document.getElementById("token1LowLegend");
      const token1HighLabelEl = document.getElementById("token1HighLabel");
      const token1LowLabelEl = document.getElementById("token1LowLabel");
      if (token1HighLegendEl) {
        token1HighLegendEl.style.display = hasPrice1 ? "inline-flex" : "none";
        if (hasPrice1) {
          const highDatasetIndex = datasets.findIndex(d => d.label === `${currentQuoteSymbol} High`);
          if (highDatasetIndex !== -1) {
            token1HighLegendEl.setAttribute("data-dataset-index", highDatasetIndex);
            token1HighLegendEl.style.cursor = "pointer";
            token1HighLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token1LowLegendEl) {
        token1LowLegendEl.style.display = hasPrice1 ? "inline-flex" : "none";
        if (hasPrice1) {
          const lowDatasetIndex = datasets.findIndex(d => d.label === `${currentQuoteSymbol} Low`);
          if (lowDatasetIndex !== -1) {
            token1LowLegendEl.setAttribute("data-dataset-index", lowDatasetIndex);
            token1LowLegendEl.style.cursor = "pointer";
            token1LowLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token1HighLabelEl && hasPrice1) {
        token1HighLabelEl.textContent = `${currentQuoteSymbol} High`;
      }
      if (token1LowLabelEl && hasPrice1) {
        token1LowLabelEl.textContent = `${currentQuoteSymbol} Low`;
      }

      // Add click functionality to Volume legend
      const volumeLegendEl = document.getElementById("volumeLegend");
      if (volumeLegendEl) {
        const volumeDatasetIndex = datasets.findIndex(d => d.label === "Volume (USD)");
        if (volumeDatasetIndex !== -1) {
          volumeLegendEl.setAttribute("data-dataset-index", volumeDatasetIndex);
          volumeLegendEl.style.cursor = "pointer";
          volumeLegendEl.classList.remove("legend-hidden");
        }
      }

      // Restore legend visual style (based on dataset hidden state)
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset, index) => {
          const legendItem = document.querySelector(`.chart-legend-item[data-dataset-index="${index}"]`);
          if (legendItem) {
            if (dataset.hidden) {
              legendItem.classList.add('legend-hidden');
            } else {
              legendItem.classList.remove('legend-hidden');
            }
          }
        });
      }

      // Setup legend click events
      setupLegendClickHandlers();
    }

    function setupLegendClickHandlers() {
      // Remove all old event listeners
      const legendItems = document.querySelectorAll('.chart-legend-item[data-dataset-index]');
      legendItems.forEach(item => {
        // Use cloneNode to remove old event listeners
        const newItem = item.cloneNode(true);
        if (item.parentNode) {
          item.parentNode.replaceChild(newItem, item);
        }
        
        // Add new click event listener
        newItem.addEventListener('click', function(e) {
          e.stopPropagation();
          const datasetIndex = parseInt(this.getAttribute('data-dataset-index'));
          if (tvlVolumeChartInstance && !isNaN(datasetIndex) && datasetIndex >= 0 && datasetIndex < tvlVolumeChartInstance.data.datasets.length) {
            const dataset = tvlVolumeChartInstance.data.datasets[datasetIndex];
            const isHidden = dataset.hidden || false;
            
            // Toggle hidden state
            dataset.hidden = !isHidden;
            tvlVolumeChartInstance.update();
            
            // Update legend visual style
            if (dataset.hidden) {
              this.classList.add('legend-hidden');
            } else {
              this.classList.remove('legend-hidden');
            }
          }
        });
      });
    }

    function updateChartFromStoredData(days) {
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        // If no stored data, clear chart
        const ctx = document.getElementById("tvlVolumeChart").getContext("2d");
        buildTvlVolumeChart(ctx, [], [], [], false, [], [], [], [], false, [], [], false, {});
        return;
      }

      // Get last N days of data from stored data
      const displayDays = days || currentDays;
      const startIndex = Math.max(0, storedOhlcvData.length - displayDays);
      const displayData = storedOhlcvData.slice(startIndex);

      const labels = [];
      const tvlData = [];
      const volData = [];
      const highData0 = [];  // token0 high
      const lowData0 = [];   // token0 low
      const highData1 = [];  // token1 high
      const lowData1 = [];   // token1 low
      let hasTvl = false;
      let hasPrice0 = false;
      let hasPrice1 = false;

      displayData.forEach(entry => {
        // Êï∞ÊçÆÊ†ºÂºè: [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
        const ts = entry[0];       // timestamp in seconds
        const _open0 = entry[1];  // token0 open
        const high0 = entry[2];   // token0 high
        const low0 = entry[3];    // token0 low
        const _close0 = entry[4]; // token0 close
        const volume = entry[5];   // volume in USD (with currency=usd)
        const tvl = entry[6];      // TVL (if available)
        const trades = entry[7];   // Daily trade count (if available)
        const _open1 = entry[8];  // token1 open
        const high1 = entry[9];   // token1 high
        const low1 = entry[10];   // token1 low
        const _close1 = entry[11]; // token1 close
        
        const date = new Date(ts * 1000);
        const label = date.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric"
        });

        labels.push(label);

        // token0 high/low price
        if (high0 != null && !isNaN(Number(high0))) {
          highData0.push(Number(high0));
          hasPrice0 = true;
        } else {
          highData0.push(null);
        }

        if (low0 != null && !isNaN(Number(low0))) {
          lowData0.push(Number(low0));
          hasPrice0 = true;
        } else {
          lowData0.push(null);
        }

        // token1 high/low price
        if (high1 != null && !isNaN(Number(high1))) {
          highData1.push(Number(high1));
          hasPrice1 = true;
        } else {
          highData1.push(null);
        }

        if (low1 != null && !isNaN(Number(low1))) {
          lowData1.push(Number(low1));
          hasPrice1 = true;
        } else {
          lowData1.push(null);
        }

        // TVL
        if (tvl != null && !isNaN(Number(tvl)) && Number(tvl) > 0) {
          tvlData.push(Number(tvl));
          hasTvl = true;
        } else {
          tvlData.push(null);
        }

        volData.push(volume);
      });

      // Save current dataset hidden state (if chart exists)
      const hiddenStates = {};
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset, index) => {
          if (dataset.label) {
            hiddenStates[dataset.label] = dataset.hidden || false;
          }
        });
      }

      const ctx = document.getElementById("tvlVolumeChart").getContext("2d");
      buildTvlVolumeChart(
        ctx,
        labels,
        tvlData,
        volData,
        hasTvl,
        [],        // openData no longer used
        highData0,
        lowData0,
        [],        // closeData no longer used
        hasPrice0,
        highData1,
        lowData1,
        hasPrice1,
        hiddenStates  // Pass hidden state
      );
    }

    async function loadPool(poolId, daysOverride) {
      const errorEl = document.getElementById("error");
      const loadingEl = document.getElementById("loading");
      const resultsEl = document.getElementById("results");
      const infoEl = document.getElementById("poolInfo");
      const rawEl = document.getElementById("rawJson");
      const birdeyeRawEl = document.getElementById("birdeyeRawJson");

      errorEl.textContent = "";
      loadingEl.textContent = "Loading from GeckoTerminal API...";
      resultsEl.style.display = "none";
      infoEl.innerHTML = "";
      rawEl.textContent = "";
      if (birdeyeRawEl) birdeyeRawEl.textContent = "";

      try {
        if (!poolId || poolId.trim() === "") {
          throw new Error("Please input a pool id (Solana pool address).");
        }

        const cleanId = poolId.trim();

        // 1, current pool snapshot
        const url = `${API_BASE}/networks/solana/pools/${cleanId}`;
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`HTTP error ${resp.status} (${resp.statusText})`);
        }
        const json = await resp.json();

        rawEl.textContent = JSON.stringify(json, null, 2);

        const data = json.data;
        if (!data || !data.attributes) {
          throw new Error("Unexpected API format, no data.attributes field.");
        }

        const attr = data.attributes;

        // Get token name, try multiple possible fields
        let baseSymbol = attr.base_token_symbol || 
                        attr.base_token?.symbol ||
                        attr.base?.symbol ||
                        attr.token0?.symbol ||
                        (data.relationships?.base_token?.data?.attributes?.symbol) ||
                        (data.relationships?.base_token?.data?.symbol) ||
                        "N/A";
        
        let quoteSymbol = attr.quote_token_symbol || 
                         attr.quote_token?.symbol ||
                         attr.quote?.symbol ||
                         attr.token1?.symbol ||
                         (data.relationships?.quote_token?.data?.attributes?.symbol) ||
                         (data.relationships?.quote_token?.data?.symbol) ||
                         "N/A";
        
        // If still N/A, try to find from included array (GeckoTerminal API usually includes this)
        if ((baseSymbol === "N/A" || quoteSymbol === "N/A") && json.included && Array.isArray(json.included)) {
          const tokens = json.included.filter(item => item.type === 'token' && item.attributes?.symbol);
          
          // Try to find corresponding token through relationships
          if (data.relationships) {
            const baseTokenId = data.relationships?.base_token?.data?.id || 
                               data.relationships?.base_token?.data?.data?.id;
            const quoteTokenId = data.relationships?.quote_token?.data?.id || 
                                data.relationships?.quote_token?.data?.data?.id;
            
            if (baseTokenId && baseSymbol === "N/A") {
              const baseToken = tokens.find(t => t.id === baseTokenId);
              if (baseToken?.attributes?.symbol) {
                baseSymbol = baseToken.attributes.symbol;
              }
            }
            
            if (quoteTokenId && quoteSymbol === "N/A") {
              const quoteToken = tokens.find(t => t.id === quoteTokenId);
              if (quoteToken?.attributes?.symbol) {
                quoteSymbol = quoteToken.attributes.symbol;
              }
            }
          }
          
          // Â¶ÇÊûúËøòÊòØÊâæ‰∏çÂà∞ÔºåÂ∞ùËØïÊåâÈ°∫Â∫èÂèñÂâç‰∏§‰∏™ token
          if (tokens.length >= 2) {
            if (baseSymbol === "N/A" && tokens[0]?.attributes?.symbol) {
              baseSymbol = tokens[0].attributes.symbol;
            }
            if (quoteSymbol === "N/A" && tokens[1]?.attributes?.symbol) {
              quoteSymbol = tokens[1].attributes.symbol;
            }
          } else if (tokens.length === 1 && baseSymbol === "N/A") {
            baseSymbol = tokens[0].attributes.symbol;
          }
        }
        
        // ÊúÄÂêéÁöÑÂ§áÁî®ÊñπÊ°àÔºöÂ∞ùËØï‰ªé name Â≠óÊÆµËß£ÊûêÔºàÂ¶ÇÊûúÊúâÊ†ºÂºèÂ¶Ç "SOL/USDC"Ôºâ
        if ((baseSymbol === "N/A" || quoteSymbol === "N/A") && attr.name) {
          const nameParts = attr.name.split('/');
          if (nameParts.length >= 2) {
            if (baseSymbol === "N/A") baseSymbol = nameParts[0].trim();
            if (quoteSymbol === "N/A") quoteSymbol = nameParts[1].trim();
          }
        }
        
        // Ë∞ÉËØïÔºöÂ¶ÇÊûúËøòÊòØ N/AÔºåËæìÂá∫Ë≠¶Âëä
        if (baseSymbol === "N/A" || quoteSymbol === "N/A") {
          console.warn("Could not find token symbols. Available attributes:", Object.keys(attr));
          console.warn("Relationships:", data.relationships);
          console.warn("Included items:", json.included?.map(i => ({ type: i.type, id: i.id, symbol: i.attributes?.symbol })));
        }
        
        // Ëé∑Âèñ token0 (base token) ÁöÑ USD ‰ª∑Ê†º
        let token0PriceUsd = attr.base_token_price_usd || 
                            attr.base_token?.price_usd ||
                            attr.token0?.price_usd ||
                            attr.price_in_usd ||
                            null;
        
        // Ëé∑Âèñ token1 (quote token) ÁöÑ USD ‰ª∑Ê†º
        let token1PriceUsd = attr.quote_token_price_usd || 
                            attr.quote_token?.price_usd ||
                            attr.token1?.price_usd ||
                            null;
        
        // Ëé∑Âèñ market_cap_usdÔºàÈÄöÂ∏∏Êù•Ëá™ base tokenÔºâ
        let marketCapUsd = attr.base_token_market_cap_usd || 
                          attr.base_token?.market_cap_usd ||
                          attr.market_cap_usd ||
                          null;
        
        // Â¶ÇÊûúËøòÊòØÊâæ‰∏çÂà∞ÔºåÂ∞ùËØï‰ªé included Êï∞ÁªÑ‰∏≠Êü•Êâæ
        if ((!token0PriceUsd || !token1PriceUsd || !marketCapUsd) && json.included && Array.isArray(json.included)) {
          const tokens = json.included.filter(item => item.type === 'token' && item.attributes);
          
          if (data.relationships) {
            const baseTokenId = data.relationships?.base_token?.data?.id || 
                               data.relationships?.base_token?.data?.data?.id;
            const quoteTokenId = data.relationships?.quote_token?.data?.id || 
                                data.relationships?.quote_token?.data?.data?.id;
            
            if (baseTokenId) {
              const baseToken = tokens.find(t => t.id === baseTokenId);
              if (baseToken?.attributes) {
                if (!token0PriceUsd && baseToken.attributes.price_usd) {
                  token0PriceUsd = baseToken.attributes.price_usd;
                }
                if (!marketCapUsd && baseToken.attributes.market_cap_usd) {
                  marketCapUsd = baseToken.attributes.market_cap_usd;
                }
              }
            }
            
            if (quoteTokenId && !token1PriceUsd) {
              const quoteToken = tokens.find(t => t.id === quoteTokenId);
              if (quoteToken?.attributes?.price_usd) {
                token1PriceUsd = quoteToken.attributes.price_usd;
              }
            }
          }
          
          // Â¶ÇÊûúËøòÊòØÊâæ‰∏çÂà∞ÔºåÂ∞ùËØïÊåâÈ°∫Â∫èÂèñÂâç‰∏§‰∏™ token
          if (tokens.length >= 2) {
            if (!token0PriceUsd && tokens[0]?.attributes?.price_usd) {
              token0PriceUsd = tokens[0].attributes.price_usd;
            }
            if (!token1PriceUsd && tokens[1]?.attributes?.price_usd) {
              token1PriceUsd = tokens[1].attributes.price_usd;
            }
            if (!marketCapUsd && tokens[0]?.attributes?.market_cap_usd) {
              marketCapUsd = tokens[0].attributes.market_cap_usd;
            }
          } else if (tokens.length === 1 && !marketCapUsd && tokens[0]?.attributes?.market_cap_usd) {
            marketCapUsd = tokens[0].attributes.market_cap_usd;
          }
        }
        
        // Ê†ºÂºèÂåñ token0 ‰ª∑Ê†º‰∏∫12‰ΩçÊúâÊïàÊï∞Â≠ó
        let token0PriceDisplay = "N/A";
        if (token0PriceUsd !== undefined && token0PriceUsd !== null && token0PriceUsd !== "N/A") {
          const priceNum = typeof token0PriceUsd === "number" ? token0PriceUsd : Number(token0PriceUsd);
          if (Number.isFinite(priceNum) && priceNum > 0) {
            token0PriceDisplay = toSignificantDigits(priceNum, 12);
          } else {
            token0PriceDisplay = String(token0PriceUsd);
          }
        }
        
        // Ê†ºÂºèÂåñ token1 ‰ª∑Ê†º‰∏∫12‰ΩçÊúâÊïàÊï∞Â≠ó
        let token1PriceDisplay = "N/A";
        if (token1PriceUsd !== undefined && token1PriceUsd !== null && token1PriceUsd !== "N/A") {
          const priceNum = typeof token1PriceUsd === "number" ? token1PriceUsd : Number(token1PriceUsd);
          if (Number.isFinite(priceNum) && priceNum > 0) {
            token1PriceDisplay = toSignificantDigits(priceNum, 12);
          } else {
            token1PriceDisplay = String(token1PriceUsd);
          }
        }
        
        // Ê†ºÂºèÂåñ market_cap_usd
        let marketCapUsdDisplay = "N/A";
        if (marketCapUsd !== undefined && marketCapUsd !== null && marketCapUsd !== "N/A") {
          const marketCapNum = typeof marketCapUsd === "number" ? marketCapUsd : Number(marketCapUsd);
          if (Number.isFinite(marketCapNum) && marketCapNum > 0) {
            // Ê†ºÂºèÂåñÂ∏ÇÂÄºÔºå‰ΩøÁî® B/M/K Âçï‰Ωç
            if (Math.abs(marketCapNum) >= 1e9) {
              marketCapUsdDisplay = (marketCapNum / 1e9).toFixed(2) + "B";
            } else if (Math.abs(marketCapNum) >= 1e6) {
              marketCapUsdDisplay = (marketCapNum / 1e6).toFixed(2) + "M";
            } else if (Math.abs(marketCapNum) >= 1e3) {
              marketCapUsdDisplay = (marketCapNum / 1e3).toFixed(2) + "K";
            } else {
              marketCapUsdDisplay = marketCapNum.toFixed(2);
            }
          } else {
            marketCapUsdDisplay = String(marketCapUsd);
          }
        }
        
        // ËÆ°ÁÆó token1/token0 ‰ª∑Ê†ºÊØîÁéáÔºàÈÄöËøáÂÇ®Â§áÈáèÊàñ USD ‰ª∑Ê†ºÔºâ
        let token1PerToken0 = null;
        let token0PerToken1 = null;
        
        // ÊñπÊ≥ï1: ‰ªéÂÇ®Â§áÈáèËÆ°ÁÆó
        const baseReserve = attr.base_token_reserve || attr.reserve_base || 
                           (attr.base_token && attr.base_token.reserve);
        const quoteReserve = attr.quote_token_reserve || attr.reserve_quote || 
                            (attr.quote_token && attr.quote_token.reserve);
        
        if (baseReserve && quoteReserve && Number(baseReserve) > 0) {
          const baseDecimals = attr.base_token_decimals || 
                              (attr.base_token && attr.base_token.decimals) || 9;
          const quoteDecimals = attr.quote_token_decimals || 
                               (attr.quote_token && attr.quote_token.decimals) || 6;
          
          const baseAmount = Number(baseReserve) / Math.pow(10, baseDecimals);
          const quoteAmount = Number(quoteReserve) / Math.pow(10, quoteDecimals);
          
          if (baseAmount > 0) {
            // token1/token0 = quoteAmount / baseAmount
            token1PerToken0 = quoteAmount / baseAmount;
            // token0/token1 = baseAmount / quoteAmount
            token0PerToken1 = baseAmount / quoteAmount;
          }
        }
        
        // ÊñπÊ≥ï2: Â¶ÇÊûúÂÇ®Â§áÈáèËÆ°ÁÆóÂ§±Ë¥•Ôºå‰ΩøÁî® USD ‰ª∑Ê†ºËÆ°ÁÆó
        if ((!token1PerToken0 || !Number.isFinite(token1PerToken0)) && 
            token0PriceUsd && token1PriceUsd && 
            Number.isFinite(Number(token0PriceUsd)) && Number.isFinite(Number(token1PriceUsd)) &&
            Number(token0PriceUsd) > 0) {
          const token0Usd = Number(token0PriceUsd);
          const token1Usd = Number(token1PriceUsd);
          // token1/token0 = (token1_usd / token0_usd)
          token1PerToken0 = token1Usd / token0Usd;
          token0PerToken1 = token0Usd / token1Usd;
        }
        
        // Ê†ºÂºèÂåñ‰ª∑Ê†ºÊØîÁéá
        let token1PerToken0Display = "N/A";
        let token0PerToken1Display = "N/A";
        
        if (token1PerToken0 && Number.isFinite(token1PerToken0) && token1PerToken0 > 0) {
          token1PerToken0Display = toSignificantDigits(token1PerToken0, 12);
        }
        
        if (token0PerToken1 && Number.isFinite(token0PerToken1) && token0PerToken1 > 0) {
          token0PerToken1Display = toSignificantDigits(token0PerToken1, 12);
        }
        
        const liquidityUsd = attr.reserve_in_usd || attr.liquidity_in_usd || "N/A";
        const dexName = attr.dex_name || "PancakeSwap V3 (Solana)";
        
        // ÊòæÁ§∫ÊúÄËøë‰∏ÄÊ¨°ÊãâÂèñÊó∂Èó¥ÁöÑÊó∂Èó¥Êà≥
        const lastUpdated = new Date().toISOString();

        infoEl.innerHTML = `
          <div class="stat-grid">
            <div class="stat">
              <div class="stat-label">DEX</div>
              <div class="stat-value">${dexName}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Pair</div>
              <div class="stat-value">${baseSymbol} / ${quoteSymbol}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Pool ID (LP ID)</div>
              <div class="stat-value">${cleanId}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${baseSymbol} Price (USD)</div>
              <div class="stat-value">
                ${token0PriceDisplay} USD
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">${quoteSymbol} Price (USD)</div>
              <div class="stat-value">
                ${token1PriceDisplay} USD
              </div>
            </div>
            <div class="stat clickable-stat" id="priceRatioStat" 
                 data-ratio-type="token1-token0"
                 data-base-symbol="${baseSymbol}"
                 data-quote-symbol="${quoteSymbol}"
                 data-token1-per-token0="${token1PerToken0Display}"
                 data-token0-per-token1="${token0PerToken1Display}">
              <div class="stat-label">
                <span id="priceRatioLabel">${quoteSymbol} / ${baseSymbol}</span>
                <span class="swap-icon" id="swapIcon">‚áÑ</span>
              </div>
              <div class="stat-value" id="priceRatioValue">
                1 ${quoteSymbol} = ${token1PerToken0Display} ${baseSymbol}
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">Volume 7d (USD)</div>
              <div class="stat-value" id="volume7dValue">ËÆ°ÁÆó‰∏≠...</div>
            </div>
            <div class="stat">
              <div class="stat-label">Market Cap (USD)</div>
              <div class="stat-value" id="marketCapUsdValue">${marketCapUsdDisplay}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Estimated Fees Per Day (USD)</div>
              <div class="stat-value" id="estimatedFeesPerDayValue">ËÆ°ÁÆó‰∏≠...</div>
            </div>
            <div class="stat">
              <div class="stat-label">Last Updated</div>
              <div class="stat-value">${lastUpdated}</div>
            </div>
          </div>
        `;

        // ‰ΩøÁî®‰º†ÂÖ•ÁöÑÂ§©Êï∞ÔºàÂ¶ÇÊûúÊúâÔºâÔºåÂê¶ÂàôÁî®ÂΩìÂâçÂÖ®Â±ÄÁöÑÂ§©Êï∞
        const days = daysOverride ?? currentDays;
        currentDays = days;

        // Êõ¥Êñ∞Ê†áÈ¢òÈáåÁöÑÂ§©Êï∞ÂíåÊªëÊùÜÁöÑ‰ΩçÁΩÆ
        const daysLabelEl = document.getElementById("daysLabel");
        const daysRangeEl = document.getElementById("daysRange");
        if (daysLabelEl) daysLabelEl.textContent = days;
        if (daysRangeEl && String(daysRangeEl.value) !== String(days)) {
          daysRangeEl.value = days;
        }

        // ‰øùÂ≠ò token Á¨¶Âè∑‰æõÂõæ‰æã‰ΩøÁî®
        currentBaseSymbol = baseSymbol;
        currentQuoteSymbol = quoteSymbol;

        // 2, fetch ohlcv - ÊÄªÊòØËé∑Âèñ180Â§©ÁöÑÊï∞ÊçÆÂπ∂Â≠òÂÇ®
        loadingEl.textContent = "Loading 180 days of OHLCV data for both tokens...";
        let ohlcvList0 = [];
        let ohlcvList1 = [];
        
        // Â∞ùËØï‰ªé Birdeye Ëé∑ÂèñÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
        try {
          const birdeyeData = await fetchBirdeyeOhlcv(cleanId, 180);
          // Birdeye ËøîÂõûÁöÑÊòØ base token ÁöÑ‰ª∑Ê†ºÔºåÊàë‰ª¨ÈúÄË¶ÅÂêåÊó∂Ëé∑Âèñ quote token
          ohlcvList0 = birdeyeData;
          // Â∞ùËØï‰ªé GeckoTerminal Ëé∑Âèñ quote token ÁöÑ‰ª∑Ê†º
          try {
            ohlcvList1 = await fetchOhlcv(cleanId, 180, "quote");
          } catch (e1) {
            console.warn("Failed to load quote token OHLCV from GeckoTerminal", e1);
          }
        } catch (e) {
          console.error("Failed to load OHLCV from Birdeye, falling back to GeckoTerminal", e);
          try {
            // ‰ªé GeckoTerminal ÂêåÊó∂Ëé∑Âèñ base Âíå quote token ÁöÑÊï∞ÊçÆ
            const [baseData, quoteData] = await Promise.all([
              fetchOhlcv(cleanId, 180, "base"),
              fetchOhlcv(cleanId, 180, "quote")
            ]);
            ohlcvList0 = baseData;
            ohlcvList1 = quoteData;
          } catch (inner) {
            console.error("Failed to load OHLCV from GeckoTerminal as well", inner);
          }
        }

        // ÂêàÂπ∂ token0 Âíå token1 ÁöÑÊï∞ÊçÆ
        // Êï∞ÊçÆÊ†ºÂºè: [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
        const mergedData = [];
        const dataMap0 = new Map();
        const dataMap1 = new Map();
        
        // Âª∫Á´ã token0 Êï∞ÊçÆÁöÑÊó∂Èó¥Êà≥Êò†Â∞Ñ
        ohlcvList0.forEach(item => {
          if (Array.isArray(item) && item.length >= 5) {
            const ts = item[0];
            const dayTs = Math.floor(ts / 86400) * 86400;
            dataMap0.set(dayTs, item);
          }
        });
        
        // Âª∫Á´ã token1 Êï∞ÊçÆÁöÑÊó∂Èó¥Êà≥Êò†Â∞Ñ
        ohlcvList1.forEach(item => {
          if (Array.isArray(item) && item.length >= 5) {
            const ts = item[0];
            const dayTs = Math.floor(ts / 86400) * 86400;
            dataMap1.set(dayTs, item);
          }
        });
        
        // ÂêàÂπ∂ÊâÄÊúâÊó∂Èó¥Êà≥
        const allTimestamps = new Set([...dataMap0.keys(), ...dataMap1.keys()]);
        const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
        
        sortedTimestamps.forEach(dayTs => {
          const item0 = dataMap0.get(dayTs);
          const item1 = dataMap1.get(dayTs);
          
          // token0 Êï∞ÊçÆ: [ts, open, high, low, close, volume, tvl?, trades?]
          const ts = item0 ? item0[0] : (item1 ? item1[0] : dayTs);
          const open0 = item0 ? (item0[1] ?? null) : null;
          const high0 = item0 ? (item0[2] ?? null) : null;
          const low0 = item0 ? (item0[3] ?? null) : null;
          const close0 = item0 ? (item0[4] ?? null) : null;
          const volume = item0 ? (item0[5] ?? 0) : (item1 ? (item1[5] ?? 0) : 0);
          const tvl = item0 ? (item0[6] ?? null) : null;
          const trades = item0 ? (item0[7] ?? 0) : 0;
          
          // token1 Êï∞ÊçÆ
          const open1 = item1 ? (item1[1] ?? null) : null;
          const high1 = item1 ? (item1[2] ?? null) : null;
          const low1 = item1 ? (item1[3] ?? null) : null;
          const close1 = item1 ? (item1[4] ?? null) : null;
          
          mergedData.push([ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]);
        });

        // Â≠òÂÇ®ÂÆåÊï¥ÁöÑ180Â§©Êï∞ÊçÆ
        storedOhlcvData = mergedData.length > 0 
          ? [...mergedData].sort((a, b) => a[0] - b[0]) 
          : [];

        // ËÆ°ÁÆóÊúÄËøë7Â§©ÁöÑÊÄªÊàê‰∫§Èáè
        let volume7d = "N/A";
        if (storedOhlcvData.length > 0) {
          // ÂèñÊúÄÂêé7Â§©ÁöÑÊï∞ÊçÆ
          const last7Days = storedOhlcvData.slice(-7);
          // ËÆ°ÁÆóÊÄªÊàê‰∫§ÈáèÔºàvolumeÂú®Á¥¢Âºï5Ôºâ
          const totalVolume = last7Days.reduce((sum, entry) => {
            const vol = entry[5] || 0; // volumeÂú®Á¥¢Âºï5
            return sum + (Number.isFinite(vol) ? Number(vol) : 0);
          }, 0);
          
          if (totalVolume > 0) {
            // Ê†ºÂºèÂåñÊòæÁ§∫
            if (Math.abs(totalVolume) >= 1e9) {
              volume7d = (totalVolume / 1e9).toFixed(2) + "B";
            } else if (Math.abs(totalVolume) >= 1e6) {
              volume7d = (totalVolume / 1e6).toFixed(2) + "M";
            } else if (Math.abs(totalVolume) >= 1e3) {
              volume7d = (totalVolume / 1e3).toFixed(2) + "K";
            } else {
              volume7d = totalVolume.toFixed(2);
            }
          } else {
            volume7d = "0";
          }
        }
        
        // Êõ¥Êñ∞7Â§©Êàê‰∫§ÈáèÊòæÁ§∫
        const volume7dEl = document.getElementById("volume7dValue");
        if (volume7dEl) {
          volume7dEl.textContent = volume7d;
        }

        // ËÆ°ÁÆó Estimated Fees Per Day = (Volume 7d / 7) * 0.01%
        let estimatedFeesPerDay = "N/A";
        if (storedOhlcvData.length > 0) {
          const last7Days = storedOhlcvData.slice(-7);
          const totalVolume = last7Days.reduce((sum, entry) => {
            const vol = entry[5] || 0;
            return sum + (Number.isFinite(vol) ? Number(vol) : 0);
          }, 0);
          
          if (totalVolume > 0) {
            const dailyVolume = totalVolume / 7;
            let feesPerDay = dailyVolume * 0.0001; // 0.01% = 0.0001
            feesPerDay *= 2; // ÂèåÂÄçÊâãÁª≠Ë¥π
            // Ê†ºÂºèÂåñÊòæÁ§∫
            if (Math.abs(feesPerDay) >= 1e9) {
              estimatedFeesPerDay = (feesPerDay / 1e9).toFixed(2) + "B";
            } else if (Math.abs(feesPerDay) >= 1e6) {
              estimatedFeesPerDay = (feesPerDay / 1e6).toFixed(2) + "M";
            } else if (Math.abs(feesPerDay) >= 1e3) {
              estimatedFeesPerDay = (feesPerDay / 1e3).toFixed(2) + "K";
            } else {
              estimatedFeesPerDay = feesPerDay.toFixed(2);
            }
          } else {
            estimatedFeesPerDay = "0";
          }
        }
        
        // Êõ¥Êñ∞ Estimated Fees Per Day ÊòæÁ§∫
        const estimatedFeesEl = document.getElementById("estimatedFeesPerDayValue");
        if (estimatedFeesEl) {
          estimatedFeesEl.textContent = estimatedFeesPerDay;
        }

        // ‰ΩøÁî®Â≠òÂÇ®ÁöÑÊï∞ÊçÆÊõ¥Êñ∞ÂõæË°®ÔºàÊòæÁ§∫ÂΩìÂâçÈÄâÊã©ÁöÑÂ§©Êï∞Ôºâ
        updateChartFromStoredData(days);

        resultsEl.style.display = "block";
        
        // ËÆæÁΩÆ‰ª∑Ê†ºÊØîÁéáÂàáÊç¢ÂäüËÉΩ
        setupPriceRatioToggle();
      } catch (e) {
        console.error(e);
        errorEl.textContent = e.message || String(e);
      } finally {
        loadingEl.textContent = "";
      }
    }

    function setupPriceRatioToggle() {
      const priceRatioStat = document.getElementById("priceRatioStat");
      if (!priceRatioStat) return;
      
      // ‰ΩøÁî® once: false Á°Æ‰øùÂèØ‰ª•Â§öÊ¨°ÁÇπÂáª
      priceRatioStat.onclick = function() {
        const currentType = this.getAttribute("data-ratio-type");
        const baseSymbol = this.getAttribute("data-base-symbol");
        const quoteSymbol = this.getAttribute("data-quote-symbol");
        const token1PerToken0 = this.getAttribute("data-token1-per-token0");
        const token0PerToken1 = this.getAttribute("data-token0-per-token1");
        
        const labelEl = document.getElementById("priceRatioLabel");
        const valueEl = document.getElementById("priceRatioValue");
        
        if (currentType === "token1-token0") {
          // ÂàáÊç¢Âà∞ token0/token1
          this.setAttribute("data-ratio-type", "token0-token1");
          if (labelEl) labelEl.textContent = `${baseSymbol} / ${quoteSymbol}`;
          if (valueEl) valueEl.textContent = `1 ${baseSymbol} = ${token0PerToken1} ${quoteSymbol}`;
        } else {
          // ÂàáÊç¢Âà∞ token1/token0
          this.setAttribute("data-ratio-type", "token1-token0");
          if (labelEl) labelEl.textContent = `${quoteSymbol} / ${baseSymbol}`;
          if (valueEl) valueEl.textContent = `1 ${quoteSymbol} = ${token1PerToken0} ${baseSymbol}`;
        }
      };
    }

    document.getElementById("loadBtn").addEventListener("click", () => {
      const poolId = document.getElementById("poolId").value;
      loadPool(poolId, currentDays);
    });

    document.getElementById("poolId").addEventListener("keyup", (e) => {
      if (e.key === "Enter") {
        loadPool(e.target.value, currentDays);
      }
    });

    const checkBirdeyeKeyBtn = document.getElementById("checkBirdeyeKeyBtn");
    if (checkBirdeyeKeyBtn) {
      checkBirdeyeKeyBtn.addEventListener("click", () => {
        checkBirdeyeKey();
      });
    }

    // ÊäòÂè†/Â±ïÂºÄËá™ÂÆö‰πâ API Key ËæìÂÖ•Âå∫Âüü
    const toggleCustomKeyBtn = document.getElementById("toggleCustomKeyBtn");
    const customKeySection = document.getElementById("customKeySection");
    const toggleCustomKeyText = document.getElementById("toggleCustomKeyText");
    const toggleCustomKeyArrow = document.getElementById("toggleCustomKeyArrow");
    
    if (toggleCustomKeyBtn && customKeySection) {
      toggleCustomKeyBtn.addEventListener("click", () => {
        const isExpanded = customKeySection.style.display !== "none";
        if (isExpanded) {
          // ÊäòÂè†
          customKeySection.style.display = "none";
          toggleCustomKeyText.textContent = "api_key_config";
          toggleCustomKeyArrow.textContent = "‚ñº";
        } else {
          // Â±ïÂºÄ
          customKeySection.style.display = "block";
          toggleCustomKeyText.textContent = "api_key_config";
          toggleCustomKeyArrow.textContent = "‚ñ≤";
        }
      });
    }

    // ÊòæÁ§∫/ÈöêËóè API Key ÊåâÈíÆ
    const toggleKeyVisibilityBtn = document.getElementById("toggleKeyVisibilityBtn");
    if (toggleKeyVisibilityBtn) {
      toggleKeyVisibilityBtn.addEventListener("click", () => {
        const keyInput = document.getElementById("birdeyeApiKey");
        if (keyInput) {
          if (keyInput.type === "password") {
            keyInput.type = "text";
            toggleKeyVisibilityBtn.textContent = "üôà";
          } else {
            keyInput.type = "password";
            toggleKeyVisibilityBtn.textContent = "üëÅÔ∏è";
          }
        }
      });
    }

    // È°µÈù¢Âä†ËΩΩÊó∂Â∞ùËØïÊÅ¢Â§çÂ≠òÂÇ®ÁöÑ keyÔºà‰ΩÜ‰∏çÊòæÁ§∫Âú®ËæìÂÖ•Ê°Ü‰∏≠Ôºå‰øùÊåÅÈöêÁßÅÔºâ
    function restoreStoredKey() {
      const storedKey = getStoredBirdeyeApiKey();
      if (storedKey) {
        const keyInput = document.getElementById("birdeyeApiKey");
        if (keyInput && !keyInput.value) {
          // ÈùôÈªòÊÅ¢Â§çÔºå‰∏çÊòæÁ§∫Âú®ËæìÂÖ•Ê°Ü‰∏≠
          // Â¶ÇÊûúÈúÄË¶ÅËá™Âä®Â°´ÂÖÖÔºåÂèñÊ∂à‰∏ãÈù¢ÁöÑÊ≥®ÈáäÔºö
          // keyInput.value = storedKey;
          console.log("Â∑≤‰ªéÊú¨Âú∞Â≠òÂÇ®ÊÅ¢Â§ç API KeyÔºàÂ∑≤Ê∑∑Ê∑ÜÔºâ");
        }
      }
    }

    // ÊªëÊùÜÔºöÂÆûÊó∂Êõ¥Êñ∞Â§©Êï∞ÔºåÂè™Êõ¥Êñ∞ÂõæË°®ÊòæÁ§∫Ôºå‰∏çÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ
    const daysRangeEl = document.getElementById("daysRange");
    if (daysRangeEl) {
      const updateChartFromSlider = () => {
        const newDays = Number(daysRangeEl.value);
        currentDays = newDays;

        const daysLabelEl = document.getElementById("daysLabel");
        if (daysLabelEl) {
          daysLabelEl.textContent = newDays;
        }

        // Âè™Êõ¥Êñ∞ÂõæË°®Ôºå‰∏çÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ
        const resultsEl = document.getElementById("results");
        if (resultsEl && resultsEl.style.display !== "none") {
          updateChartFromStoredData(newDays);
        }
      };

      daysRangeEl.addEventListener("input", updateChartFromSlider);
      daysRangeEl.addEventListener("change", updateChartFromSlider);
    }

    // Popular pools data
    const popularPools = [
      { name: "cbBTC/USDC", id: "7ENJsaWAy4PRs24NYd1WqUdY3DWi43rHvyZXhCjEiNWE" },
      { name: "SOL/USDT", id: "22HUWiJaTNph96KQTKZVy2wg8KzfCems5nyW7E5H5J6w" },
      { name: "SOL/USDC", id: "DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ" },
      { name: "USDC/USDT", id: "46Z4iBRb8Kwj2qBoDyLAWt99vKXsUS1vE7vFU2vy5x2V" },
      { name: "SOL/HYPE", id: "4nDy9TQUTfqbmexZi25ujv11KMkDfFMmGeKPRw8HryWY" },
      { name: "SOL/WBTC", id: "GLfJcQZgtLV2QyEBxmNNZ75uJFG1VRiLiki8PfcTZQjW" },
      { name: "USD1/USDC", id: "CWNajRMzUb7ywfuVu9N7b9myhm6GPGFVNaMNAPkNpSjn" },
      { name: "CAKE/USDC", id: "J734vwZxCrrFLhGxwkZdFo3537snbYtLbkvtM15HkETr" },
    ];

    // Initialize popular pools scroll bar
    function initPopularPools() {
      const scrollContainer = document.getElementById("popularPoolsScroll");
      if (!scrollContainer) return;

      // Create pool items (duplicate for seamless loop)
      const createPoolItems = () => {
        return popularPools.map(pool => {
          const item = document.createElement("div");
          item.className = "popular-pool-item";
          item.textContent = pool.name;
          item.dataset.poolId = pool.id;
          item.addEventListener("click", () => {
            const poolIdInput = document.getElementById("poolId");
            if (poolIdInput) {
              poolIdInput.value = pool.id;
              // Automatically trigger Load Pool button
              const loadBtn = document.getElementById("loadBtn");
              if (loadBtn) {
                loadBtn.click();
              } else {
                // Fallback: directly call loadPool if button not found
                loadPool(pool.id, currentDays);
              }
            }
          });
          return item;
        });
      };

      // Duplicate items for seamless scrolling
      const items = createPoolItems();
      const duplicatedItems = createPoolItems();
      
      items.forEach(item => scrollContainer.appendChild(item));
      duplicatedItems.forEach(item => scrollContainer.appendChild(item));
    }

    window.addEventListener("load", () => {
      // Initialize popular pools
      initPopularPools();
      
      // Â∞ùËØïÊÅ¢Â§çÂ≠òÂÇ®ÁöÑ API Key
      restoreStoredKey();
      
      const poolId = document.getElementById("poolId").value;
      loadPool(poolId, currentDays);
      // Â¶ÇÊûúÁî®Êà∑Â∑≤ËæìÂÖ• Birdeye API KeyÔºåÂàôÊ£ÄÊü•ÂÖ∂ÊòØÂê¶ÂèØÁî®
      checkBirdeyeKey();
    });

    // ========= Impermanent Loss Monte Carlo Simulator =========

    let ilChartInstance = null;

    function randnBoxMuller() {
      let u = 0;
      let v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function uniswapV3XYForPrice(P, Pl, Pu, L) {
      const sqrtP = Math.sqrt(P);
      const sqrtPl = Math.sqrt(Pl);
      const sqrtPu = Math.sqrt(Pu);

      if (P <= Pl) {
        const x = L * (1 / sqrtPl - 1 / sqrtPu);
        return { x, y: 0 };
      } else if (P >= Pu) {
        const y = L * (sqrtPu - sqrtPl);
        return { x: 0, y };
      } else {
        const x = L * (1 / sqrtP - 1 / sqrtPu);
        const y = L * (sqrtP - sqrtPl);
        return { x, y };
      }
    }

    function buildIlDistributionChart(labels, counts) {
      const ctx = document.getElementById("ilDistributionChart").getContext("2d");
      if (ilChartInstance) {
        ilChartInstance.destroy();
      }

      ilChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              label: "Frequency",
              data: counts,
              backgroundColor: "rgba(148, 163, 184, 0.65)",
              borderColor: "rgba(148, 163, 184, 0.95)",
              borderWidth: 1,
              maxBarThickness: 18
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.6)",
              borderWidth: 1,
              padding: 8,
              callbacks: {
                label: (ctx) => {
                  const label = ctx.label || "";
                  const c = ctx.parsed.y;
                  return `${label}: ${c}`;
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                maxRotation: 0,
                minRotation: 0
              },
              grid: { display: false }
            },
            y: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                precision: 0
              },
              grid: {
                color: "rgba(30, 64, 175, 0.25)"
              }
            }
          }
        }
      });
    }

    function runIlSimulation() {
      const lowerEl = document.getElementById("ilLower");
      const upperEl = document.getElementById("ilUpper");
      const p0El = document.getElementById("ilP0");
      const sigmaDailyEl = document.getElementById("ilSigmaDaily");
      const daysEl = document.getElementById("ilDays");
      const pathsEl = document.getElementById("ilPaths");
      const statusEl = document.getElementById("ilStatus");
      const errorEl = document.getElementById("ilError");

      const expectedEl = document.getElementById("ilExpected");
      const ciEl = document.getElementById("ilCI");
      const stdEl = document.getElementById("ilStd");
      const aprEl = document.getElementById("ilApr");
      const feeBreakEvenEl = document.getElementById("ilFeeBreakEven");

      errorEl.textContent = "";
      statusEl.textContent = "Running Monte Carlo simulation...";
      expectedEl.textContent = "‚Äì";
      ciEl.textContent = "‚Äì";
      stdEl.textContent = "‚Äì";
      if (aprEl) aprEl.textContent = "‚Äì";
      if (feeBreakEvenEl) feeBreakEvenEl.textContent = "‚Äì";

      const Pl = Number(lowerEl.value);
      const Pu = Number(upperEl.value);
      const P0 = Number(p0El.value);
      const sigmaDailyPct = Number(sigmaDailyEl.value);
      const days = Number(daysEl.value);
      let paths = Number(pathsEl.value);

      if (!Number.isFinite(Pl) || !Number.isFinite(Pu) || !Number.isFinite(P0)) {
        errorEl.textContent = "ËØ∑Â°´ÂÜôÊúâÊïàÁöÑ‰ª∑Ê†ºÔºåÂåÖÂê´Âå∫Èó¥‰∏ãÁïå„ÄÅ‰∏äÁïåÂíåÂΩìÂâç‰ª∑Ê†º„ÄÇ";
        statusEl.textContent = "";
        return;
      }
      if (Pl <= 0 || Pu <= 0 || P0 <= 0) {
        errorEl.textContent = "‰ª∑Ê†ºÂøÖÈ°ªÂ§ß‰∫é 0„ÄÇ";
        statusEl.textContent = "";
        return;
      }
      if (Pl >= Pu) {
        errorEl.textContent = "Âå∫Èó¥‰∏ãÁïåÂøÖÈ°ªÂ∞è‰∫é‰∏äÁïå„ÄÇ";
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(sigmaDailyPct) || sigmaDailyPct <= 0) {
        errorEl.textContent = "ËØ∑Â°´ÂÜôÊúâÊïàÁöÑÊó•Ê≥¢Âä®ÁéáÔºàÁôæÂàÜÊØîÔºâ„ÄÇ";
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(days) || days <= 0) {
        errorEl.textContent = "È¢ÑÊµãÂ§©Êï∞ÂøÖÈ°ª‰∏∫Ê≠£Êï¥Êï∞„ÄÇ";
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(paths) || paths < 100) {
        paths = 1000;
      }

      const sigmaDaily = sigmaDailyPct / 100;
      const T = days;

      const L = 1;
      const xy0 = uniswapV3XYForPrice(P0, Pl, Pu, L);
      const x0 = xy0.x;
      const y0 = xy0.y;

      const ils = new Array(paths);

      for (let i = 0; i < paths; i++) {
        const z = randnBoxMuller();
        const logPT =
          Math.log(P0) +
          (-0.5 * sigmaDaily * sigmaDaily) * T +
          sigmaDaily * Math.sqrt(T) * z;
        const PT = Math.exp(logPT);

        const xyT = uniswapV3XYForPrice(PT, Pl, Pu, L);
        const xT = xyT.x;
        const yT = xyT.y;

        const vHodl = x0 * PT + y0;
        const vLp = xT * PT + yT;

        const il = vLp / vHodl - 1;
        ils[i] = il;
      }

      ils.sort((a, b) => a - b);

      const n = ils.length;
      const mean =
        ils.reduce((acc, v) => acc + v, 0) / n;

      let variance = 0;
      for (let i = 0; i < n; i++) {
        const d = ils[i] - mean;
        variance += d * d;
      }
      variance = variance / Math.max(1, n - 1);
      const std = Math.sqrt(variance);

      const idx5 = Math.floor(0.05 * (n - 1));
      const idx95 = Math.floor(0.95 * (n - 1));
      const il5 = ils[idx5];
      const il95 = ils[idx95];

      const toPercent = (x) => (x * 100).toFixed(3) + " %";

      expectedEl.textContent = toPercent(mean);
      ciEl.textContent = `${toPercent(il5)}  ~  ${toPercent(il95)}`;
      stdEl.textContent = toPercent(std);

      // ËÆ°ÁÆóÁ≠âÊïà IL APRÔºöÂ∞Ü IL Âπ¥Âåñ
      // mean ÊòØÂ∞èÊï∞ÂΩ¢ÂºèÔºà‰æãÂ¶Ç -0.025 Ë°®Á§∫ -2.5%Ôºâ
      // Á≠âÊïà APR = (mean / days) * 365ÔºàÂ∞èÊï∞ÂΩ¢ÂºèÔºå‰æãÂ¶Ç -0.30417 Ë°®Á§∫ -30.417%Ôºâ
      const equivalentIlApr = (mean / days) * 365;
      if (aprEl) {
        aprEl.textContent = toPercent(equivalentIlApr);
      }

      // ËÆ°ÁÆóÊâãÁª≠Ë¥πÁõà‰∫èÂπ≥Ë°°Á∫ø APRÔºöÈúÄË¶ÅÂ§öÂ∞ëÊâãÁª≠Ë¥π APR ÊâçËÉΩÊäµÊ∂à IL ÊçüÂ§±
      // ÊâãÁª≠Ë¥πÁõà‰∫èÂπ≥Ë°°Á∫ø = |Á≠âÊïà IL APR|
      const feeBreakEvenApr = Math.abs(equivalentIlApr);
      if (feeBreakEvenEl) {
        feeBreakEvenEl.textContent = toPercent(feeBreakEvenApr);
      }

      const minIl = ils[0];
      const maxIl = ils[n - 1];
      let lo = minIl;
      let hi = maxIl;
      if (hi - lo < 1e-6) {
        lo -= 0.0005;
        hi += 0.0005;
      }

      const binCount = 30;
      const binSize = (hi - lo) / binCount;
      const counts = new Array(binCount).fill(0);
      const labels = new Array(binCount);

      for (let i = 0; i < binCount; i++) {
        const mid = lo + (i + 0.5) * binSize;
        labels[i] = (mid * 100).toFixed(2) + "%";
      }

      for (let i = 0; i < n; i++) {
        let idx = Math.floor((ils[i] - lo) / binSize);
        if (idx < 0) idx = 0;
        if (idx >= binCount) idx = binCount - 1;
        counts[idx] += 1;
      }

      buildIlDistributionChart(labels, counts);

      statusEl.textContent = `Done. Simulated ${paths} paths over ${days} days (œÉ‚Ççdaily‚Çé = ${sigmaDailyPct}%).`;
    }

    const runIlBtn = document.getElementById("runIlBtn");
    if (runIlBtn) {
      runIlBtn.addEventListener("click", runIlSimulation);
    }

    // ÂàùÂßãÊÉÖÂÜµ‰∏ãÂ∞±ËøêË°åÊ®°ÊãüÔºå‰ΩøÁî®ÈªòËÆ§ÂèÇÊï∞
    window.addEventListener("load", () => {
      setTimeout(() => {
        runIlSimulation();
      }, 1000); // Âª∂Ëøü1ÁßíÁ°Æ‰øùDOMÂíåÂõæË°®Â∫ìÂÆåÂÖ®Âä†ËΩΩ
    });
  </script>
</body>
</html>
